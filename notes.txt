the name "realisr" comes from:
    RLSR (randomized linked segmented rescale)
        This is why I use the british spelling; the acronym has an S not a Z.
    The theoretical backing of this project was projecting music from complex time into real time, so literally "making real" or "realizing".
    So, its a double entendre of sorts :)

"Classic" mode:
    Split input audio into segments, stretch those segments and keep them connected; an LSR (linked segmented rescale)
    Segments were always uniform in Realisr 1, but maybe allow the user to edit the initial segmentation as well
"True timeplot" mode:
    - simply take any timeplot and lay the real audio along it, then project to the real axis. This is what I was first (mistakenly) coding in Rust
    - should have the option to pre-scale the audio to make up for the net pitch increase (since  everything will be higher pitched in this mode by default)


DONE - Iterate through vectors to gather important info:
    record max and min x values (to compute plot width)
    record how far along the path each vector is (this lets us know later where each segment comes from in the input audio)
    sum up total path length

Illustration:
    p5.js for a demo, but this is not performant so should be replaced eventually with...
    D3? svg based, might be a good time to learn D3...
    Cytoscape? canavas based, pretty well optimized it seems https://js.cytoscape.org



Old notes:
- Port realisr to Rust/WASM so it can be done efficiently, in the browser, client-side
- use svelte to wrap the UI
- add subdivision feature
    1. simple angle and length subdividing, like I experimented with on the original realisr
    2. iterative subdividing, preserving the measure transition points
    3. bezier curves
- add an editor where you can just draw the time plot and input some audio
